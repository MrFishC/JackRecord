# 一.目标：
+ 1.涉及的设计模式
+ 2.弄清楚Okhttp大体的工作流程
+ 3.对Okhttp一些问题做出解答

# 二.Okhttp的大体工作流程
+ 拿一次网络请求举例，粗略的工作过程
  + 1.Call对象对请求的封装；
  + 2.Dispatcher对象对请求的分发；
  + 3.执行getResponseWithInterceptorChain方法；

# 三.白话描述
+ 1.责任链模式的工作流程
  + 1.1.要捋清楚该流程，需要把对应的对象先找到，暂时先不管应用拦截器和网络拦截器，只关注系统默认的5个拦截器，即已经有5个类了。然后就是找到RealCall类（真实的请求对象），和真实的拦截器链
（RealInterceptorChain）对象，一共就是7个对象。我们只要分析RealCall类中的根据拦截器链获取响应（getResponseWithInterceptorChain）的方法即可，捋清楚5个系统拦截器和真实的拦截器链
在该方法中的工作流程，即可弄明白Okhttp的责任链模式的工作流程；
  + 1.2.首先，创建一个装拦截器的集合，分别把重试拦截器（RetryAndFollowUpInterceptor），桥接拦截器（BridgeInterceptor），缓存拦截器（CacheInterceptor），连接拦截器（ConnectInterceptor），
请求服务的拦截器（CallServerInterceptor）添加到集合。如果客户端在创建Okhttpclient的时候添加了应用和网络拦截器，那么该集合会最先添加应用拦截器，在添加请求服务拦截器之前添加网络拦截器，不过
我们这里就不分析应用和网络拦截器。把系统默认的5个拦截器的工作流程捋清楚自然可以很清晰把应用和网络拦截器捋清楚；
  + 1.3.拦截器被添加到集合之后，构建真实的拦截器链对象，并把上一步创建的集合等设置好。接着调用真实拦截器链的proceed方法，把请求作为参数设置进去，而Okhttp责任链模式的工作流程就是在该方法中完成的；
  + 1.4.在调用真实拦截器链的proceed方法中会继续创建下一个真实拦截器链对象，并获取根据当前真实拦截器的index索引去获取集合中的拦截器，即重试拦截器。
  + 1.5.下一步就是调用重试拦截器的拦截方法，并把上一步创建好的下一个真实拦截器作为参数传递。如此就要分析重试拦截器的拦截方法；
  + 1.6.在重试拦截器的拦截方法中，会调用下一个真实拦截器对象的proceed，又回到前面2步分析的逻辑当中，创建新的真实拦截器链，获取集合中的下一个拦截器，继续调用下一次拦截器（即BridgeInterceptor）
  的拦截（intercept）方法，如此就形成一个类似递归的操作。缓存拦截器，连接连接器，请求服务的拦截器都是类似的执行；
  + 1.7.当最后一个请求服务的拦截器执行完它的拦截方法后，它会把Response返回给它上一个拦截器intercept方法中的RealInterceptorChain的proceed方法，其它拦截器也是类似，就完成了Response依次从
  请求服务的拦截器、连接拦截器、缓存拦截器、桥接拦截器、重试拦截器的一个回传；
  + 1.8.当然每一个拦截器在其拦截方法中都做了自己的工作。如此，责任链模式的工作流程就清晰了；

# 问题汇总
+ 1.Okhttp的责任链模式是怎么运行的
+ 2.Retrofit和Okhttp的不同有哪些
+ 3.Okhttp的拦截器模式是怎么做的
+ 4.Okhttp的源码核心
+ 5.为什么设计者要设计成核心线程，队列缓冲，在加工作线程的模式，而不是直接使用核心线程+工作线程+队列缓冲的形式。
  + 设计者应该是考虑使用线程池是可以选择性能和稳定的，如果都是直接创建线程，那资源开销会很大，如果我们有个队列，
那我们如要需要性能，可以用SynchronousQueue，例如Okhttp内部就是用的这个，不需要队列阻塞，直接构建工作线程来执行。
+ 6.okhttp的连接池是怎么复用的
